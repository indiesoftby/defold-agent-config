-- SPDX-License-Identifier: CC0-1.0

local M = {}

local PREF_EPSILON = "gen_silhouette_chain.epsilon"
local PREF_THICKNESS = "gen_silhouette_chain.thickness"
local EPSILON_OPTIONS = {"0.5", "1.0", "1.5", "2.0", "3.0", "4.0", "5.0", "8.0", "10.0"}
local THICKNESS_OPTIONS = {"1.0", "1.5", "2.0", "3.0", "4.0", "5.0"}
local SCRIPT_PATH = ".agents/skills/defold-proto-file-editing/scripts/gen_silhouette_chain.py"
local SPRITE_IMAGE_PROP = "__sampler__texture_sampler__0"

function M.get_prefs_schema()
	return {
		[PREF_EPSILON] = editor.prefs.schema.enum({
			values = EPSILON_OPTIONS,
			default = "2.0",
			scope = editor.prefs.SCOPE.PROJECT
		}),
		[PREF_THICKNESS] = editor.prefs.schema.enum({
			values = THICKNESS_OPTIONS,
			default = "2.0",
			scope = editor.prefs.SCOPE.PROJECT
		})
	}
end

local silhouette_dialog = editor.ui.component(function(props)
	local epsilon, set_epsilon = editor.ui.use_state(props.default_epsilon)
	local thickness, set_thickness = editor.ui.use_state(props.default_thickness)

	return editor.ui.dialog({
		title = "Generate Silhouette Chain",
		content = editor.ui.vertical({
			padding = editor.ui.PADDING.LARGE,
			spacing = editor.ui.SPACING.LARGE,
			children = {
				editor.ui.paragraph({
					text = "Generates a .collisionobject with embedded TYPE_BOX shapes that trace "
						.. "the image silhouette contour. Useful for concave static collision "
						.. "(race tracks, terrain). The result is saved as \""
						.. props.output_name .. "\"."
				}),
				editor.ui.grid({
					columns = {{}, {grow = true}},
					children = {
						{
							editor.ui.label({text = "Image", alignment = editor.ui.ALIGNMENT.RIGHT}),
							editor.ui.label({text = props.image_name})
						},
						{
							editor.ui.label({text = "Epsilon (px)", alignment = editor.ui.ALIGNMENT.RIGHT}),
							editor.ui.select_box({
								value = epsilon,
								options = EPSILON_OPTIONS,
								on_value_changed = set_epsilon
							})
						},
						{
							editor.ui.label({text = "Thickness (px)", alignment = editor.ui.ALIGNMENT.RIGHT}),
							editor.ui.select_box({
								value = thickness,
								options = THICKNESS_OPTIONS,
								on_value_changed = set_thickness
							})
						}
					}
				})
			}
		}),
		buttons = {
			editor.ui.dialog_button({text = "Cancel", cancel = true}),
			editor.ui.dialog_button({text = "Generate", default = true, result = {epsilon = epsilon, thickness = thickness}})
		}
	})
end)

--- Find image resource path for a sprite's default animation from its atlas.
---@param atlas_path string resource path to atlas (e.g. "/assets/hero.atlas")
---@param default_animation string animation/image id from the sprite
---@return string|nil image_path resource path to the image file
---@return string|nil error_message
local function find_sprite_image(atlas_path, default_animation)
	-- Check bare images: id is filename without extension
	local image_nodes = editor.get(atlas_path, "images")
	for i = 1, #image_nodes do
		local img_path = editor.get(image_nodes[i], "image")
		local filename = img_path:match("([^/]+)$")
		local img_id = filename:match("^(.+)%.[^.]+$") or filename
		if img_id == default_animation then
			return img_path
		end
	end

	-- Check animations: id is the animation's id field
	local anim_nodes = editor.get(atlas_path, "animations")
	for i = 1, #anim_nodes do
		local anim_id = editor.get(anim_nodes[i], "id")
		if anim_id == default_animation then
			-- Get first image of the animation
			local anim_image_nodes = editor.get(anim_nodes[i], "images")
			if #anim_image_nodes > 0 then
				return editor.get(anim_image_nodes[1], "image")
			end
		end
	end

	-- Fallback: return first image in the atlas
	if #image_nodes > 0 then
		return editor.get(image_nodes[1], "image")
	end
	if #anim_nodes > 0 then
		local anim_image_nodes = editor.get(anim_nodes[1], "images")
		if #anim_image_nodes > 0 then
			return editor.get(anim_image_nodes[1], "image")
		end
	end

	return nil, "No image found for animation '" .. default_animation .. "' in atlas " .. atlas_path
end

function M.get_commands()
	return {
		-- Command 1: Generate from image file in Assets panel
		{
			label = "Generate Silhouette Chain...",
			locations = {"Assets"},
			query = {
				selection = {type = "resource", cardinality = "one"}
			},
			active = function(opts)
				local path = editor.get(opts.selection, "path")
				return path:match("%.png$") ~= nil
					or path:match("%.jpg$") ~= nil
					or path:match("%.jpeg$") ~= nil
			end,
			run = function(opts)
				local path = editor.get(opts.selection, "path")
				local image_name = path:match("[^/]+$")
				local output_name = image_name:gsub("%.[^.]+$", ".collisionobject")
				local saved_epsilon = editor.prefs.get(PREF_EPSILON)
				local saved_thickness = editor.prefs.get(PREF_THICKNESS)
				local result = editor.ui.show_dialog(silhouette_dialog({
					image_name = image_name,
					output_name = output_name,
					default_epsilon = saved_epsilon,
					default_thickness = saved_thickness
				}))
				if not result then
					return
				end
				editor.prefs.set(PREF_EPSILON, result.epsilon)
				editor.prefs.set(PREF_THICKNESS, result.thickness)
				local rel_path = path:sub(2)
				local output_path = rel_path:gsub("%.[^.]+$", ".collisionobject")
				editor.execute(
					"python",
					SCRIPT_PATH,
					rel_path,
					"-o", output_path,
					"-e", result.epsilon,
					"-t", result.thickness
				)
			end
		},
		-- Command 2: Generate from Sprite component in Outline panel
		{
			label = "Generate Silhouette Chain...",
			locations = {"Outline"},
			query = {
				selection = {type = "outline", cardinality = "one"}
			},
			active = function(opts)
				local node = opts.selection
				return editor.can_get(node, SPRITE_IMAGE_PROP)
					and editor.can_get(node, "default_animation")
			end,
			run = function(opts)
				local node = opts.selection

				-- Read sprite properties
				local atlas_path = editor.get(node, SPRITE_IMAGE_PROP)
				local default_animation = editor.get(node, "default_animation")

				if not atlas_path or atlas_path == "" then
					print("ERROR: Sprite has no atlas/image set")
					return
				end

				-- Find the actual image file from the atlas
				local image_path, err = find_sprite_image(atlas_path, default_animation)
				if not image_path then
					print("ERROR: " .. (err or "Unknown error"))
					return
				end

				-- Determine output path
				local image_name = image_path:match("[^/]+$")
				local output_name = image_name:gsub("%.[^.]+$", ".collisionobject")

				-- Show dialog
				local saved_epsilon = editor.prefs.get(PREF_EPSILON)
				local saved_thickness = editor.prefs.get(PREF_THICKNESS)
				local result = editor.ui.show_dialog(silhouette_dialog({
					image_name = image_name,
					output_name = output_name,
					default_epsilon = saved_epsilon,
					default_thickness = saved_thickness
				}))
				if not result then
					return
				end
				editor.prefs.set(PREF_EPSILON, result.epsilon)
				editor.prefs.set(PREF_THICKNESS, result.thickness)

				-- Generate .collisionobject file
				local image_rel_path = image_path:sub(2)
				local output_rel_path = image_rel_path:gsub("%.[^.]+$", ".collisionobject")
				editor.execute(
					"python",
					SCRIPT_PATH,
					image_rel_path,
					"-o", output_rel_path,
					"-e", result.epsilon,
					"-t", result.thickness
				)
			end
		}
	}
end

return M
